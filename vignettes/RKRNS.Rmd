---
title: "BOLD decoding with the RKRNS package"
bibliography: REFERENCES.bib
output:
  pdf_document:
    toc: true
    highlight: zenburn
  ioslides_presentation:
    incremental: false
    widescreen: true
    smaller: false
  revealjs_presentation:
    pandoc_args: [ "--slide-level", "2" ]
    incremental: true
    widescreen: true
    smaller: false
    theme: simple
    transition: fade
    highlight: pygments
    center: true
    self_contained: false
  html_document:
    toc: true
    theme: readable
---
<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{BOLD decoding with the RKRNS package}
-->

# Introduction

Decoding from blood oxygenation-level dependent (BOLD) magnetic resonance imaging (MRI) data 
remains an esoteric art.  Relatively few public datasets exist and these are rarely accompanied 
by accessible and validated, general-purpose decoding methodology.  This package seeks to 
document some relatively standard approaches to processing BOLD data and follow with a few 
novel extensions.  These are implemented via *R*, its packages and *ANTsR*.

## RKRNS Algorithms 

This package integrates several frameworks for BOLD processing:

- core image processing and I/O: ITK (@Avants2014a);

- registration and utilities for image processing: ANTs (@Tustison2014) and ANTsR (@ANTsR);

- hemodynamic response function estimation: influenced by GLMdenoise (@Kay2013) and finite impulse response (@Kay2008) estimates;

- dimensionality reduction: Eigenanatomy (@Dhillon2014) and SCCAN (@Avants2014);

- temporal filtering via *R* packages.

In combination, these tools enable one to go from near-raw medical imaging data 
to a BOLD decoding experiment.  

## Data organization expected by RKRNS

We make several assumptions about data organization 
with this package.

- The BOLD time series will be masked and converted to a matrix.  This will be known as "the BOLD matrix."

- The design matrix will have one event type per column and will be binary.

- The design matrix matches the bold matrix *in time* at an index level.  Thus, 
  it has the same number of rows (volumes) as the BOLD matrix. So, the i$^{th}$ row 
  of the design matrix corresponds to the i$^{th}$ BOLD volume.  We provide some 
  utilities to assist in assembling the BOLD volumes to match the design matrix in 
  this manner.

Overall, this simple approach aids debugging though has some shortcomings (i.e. rounded even onsets).

# Decoding in simulated data

Here, we outline test data that is similar to what one may acquire in a real 
event related design.  However, in this data, there is no need for motion correction.

## Example BOLD Data

We adapted methods from the *neuRosim* (@neuRosim) package in order to simulate 
event-related BOLD data.  This data involves a 4-class decoding task wherein one 
seeks to identify brain responses to novel faces, famous faces and their first 
and second presentations to the subject.  We distribute the underlying anatomical 
BOLD data along with a cortical mask within the package.  The data may be 
loaded by:
```{r simdata}
library(RKRNS)
fn<-paste(path.package("RKRNS"),"/extdata/111157_mocoref_masked.nii.gz",sep="") 
eximg<-antsImageRead(fn,3)
fn<-paste(path.package("RKRNS"),"/extdata/subaal.nii.gz",sep="") 
mask<-antsImageRead(fn,3)
```
which gives you both the cortical `mask` and the example BOLD signal 
image `eximg`.  ANTsR also provides AAL label (@Tzourio-Mazoyer2002) names via:
```{r aal}
data(aal,package='ANTsR')
labs<-1:90
```
with cortical labs defined by `labs`.

## Run the simulation
We generate simulated bold data as in neuRosim.  
The `simulateBOLD` function results in a bold image 
in the `antsImage` class.  We subsequently convert 
this image to a $n\times p$ matrix where there are 
$n$ time volumes and $p$ voxels in the mask.
```{r simb}
bb<-simulateBOLD(option="henson",eximg=eximg,mask=mask)
boldImage<-bb$simbold
mat<-timeseries2matrix( boldImage, bb$mask )
```
The data frame containing the bold image also contains the design
matrix.  One should inspect that matrix to get an idea of the
structure expected by RKRNS.  Row names and column names are expected
to exist in the design matrix dataframe.

Perform some diagnostic visualizations on the data.
```{r simbviz}
randvox<-sample(1:ncol(mat),4)
plot(ts(mat[,randvox]))
```
The time series is noisy, as expected.

## Frequency filtering
Let's get rid of high frequency noise.
```{r ffilt}
# only filter high frequencies 1/(2*tr)
filtmat<-filterfMRI4KRNS( data.matrix(mat), tr=1, NA, NA, trendfrequency=2, trendfrequency2=NA )
plot(ts(filtmat[,randvox]))
```
We can eliminate low frequency contamination with polynomial regressors 
and other denoising techniques at a later step.

## Autoregression 
Probably not good for decoding, but 
we can also model autoregression coefficients.
```{r arfilt}
armat<-arCorrection( mat )
print(armat$arcoefs)
plot(ts(armat$outmat[,randvox]))
```
The `armat$arcoefs` indicate auto-correlation levels 
of the input data.  This function tries to shrink 
these levels toward zero.

## Estimate $\beta$ values for each event
We estimate a $\beta^i$ vector for each of $i \in 1 \cdots q$ events.
This vector contains a scalar $\beta$ value for each voxel,
i.e. $\beta_j^i$ where $j \in 1 \cdots p$.  This example 
can be found via `?bold2betas`.
```{r simb2b}
btsc<-bold2betas( boldmatrix=data.matrix(mat), 
      designmatrix=bb$desmat[,1:4], baseshift=1,
      blockNumb=bb$desmat$Run, maxnoisepreds=0,
      bl=8, polydegree=4, selectionthresh=0.2 )
mylabs<-rep("",nrow(btsc$eventbetas))
for ( i in 1:nrow(btsc$eventbetas) ) mylabs[i]<-substr( rownames(btsc$eventbetas)[i],1,2)
mylabs<-as.factor(mylabs)
```
We recommend that one looks at the estimated hemodynamic response
function in order to help set parameters.  This is available as output
from the `bold2betas` function (and `glmDenoiseR`).  Key parameters
are the basis length for HRF estimation, the maximum number of noise
predictors (e.g. `maxnoisepreds=4` or `maxnoisepreds=2:10` to search a
range), the polynomial degree and the `selectionthresh` which should
be kept below `0.5`. Real data processing should proceed similarly.
The latter part of the sample code extracts labels from the rownames
of the output event beta dataframe.  This will set us up for decoding.

## Visualize the HRF
Take a quick look at the estimated hemodynamic response function.
```{r vizhrf}
plot(ts(btsc$hrf))
```
If this doesn't look "normal," then there may be a problem.
One might also do an SVD on the run-wise HRFs and derive a 
more flexible basis set for your study.

## Decode from event-wise $\beta$

Here, we use effect sizes to focus our decoding 
on a subset of the full voxel matrix which is 
of size `ncol(mat)`.
```{r simdecode}
# sample for training
inds<-sample(1:nrow(btsc$eventbetas),size=round(nrow(btsc$eventbetas)*1./2.))
# basic voxel selection using effect size & classification
zz<-apply(btsc$eventbetas,FUN=mean,MARGIN=2)
zze<-zz/apply(btsc$eventbetas,FUN=sd,MARGIN=2)
th<-0.5
ff<-which( abs(zze) > th )
mydf<-data.frame( lab=mylabs,  vox=data.matrix(btsc$eventbetas)[,ff])
mdl<-svm( lab ~., data=mydf[inds,])
err<-sum(mydf[-inds,]$lab==predict( mdl, newdata=mydf[-inds,]))/nrow(mydf[-inds,])
print(paste("NPredVox",length(ff),"Correct",err*100))
```
The "high effect size" voxels are sent to a naive support 
vector machine to do training (on a fraction of the data) 
and testing on the left out data.

# Real data processing with RKRNS

We recommend that you motion correct the data 
before you use RKRNS tools.  This should be done 
once and done well.  Good approaches exist in *ANTsR* 
which yield both motion matrices and relevant summary 
measurements such as FD and DVARS.  See `?antsPreprocessfMRI` 
for a simplified utility function.  This function could be 
used on each run of an experiment and the results stored 
in organized fashion for later use. 

## Motion correction
To motion correct your data, one might run:
```{r motioncorr}
# get an average image
averageImage <- getAverageOfTimeSeries( boldImage )
motionCorrectionResults <- motion_correction(boldImage, 
   fixed = averageImage, moreaccurate = FALSE)
```
Set the `moreaccurate` flag to `TRUE` for usable (not test) results.
You might also estimate FD and DVARS from these results.  One might 
use `antsPreprocessfMRI` to get these directly.  Note, however, to 
turn this function's frequency filtering off if you want to do decoding.

## BOLD assembly 

## BOLD preprocessing

## BOLD signal characteristics 

BOLD signal is information rich but noisy.  We employ three
fundamental aspects of BOLD to guide our preprocessing choices:

- Physiological noise contaminates the BOLD signal ( see compcor @Behzadi2007 )
- The BOLD response is slow ( > 5 seconds ) after a stimulus
- The response has limited temporal extent ( < 25 seconds )

## Processing decisions
```{r filtering}
afilterlowfrequency<-4
afilterhighfrequency<-20
```
Our processing therefore uses the following steps:

1. Assemble the BOLD blocks to match the overall event-related design file 
    - optionally use anatomical labeling to select subregions for assembly
    - preliminary studies use language network regions: `r aal$label_name[labs]`.
1. Learn physiological noise parameters from 1 block and apply them to the rest
1. Filter the fMRI with a Butterworth band-pass filter, extracting select mid-range frequencies
    - low frequency is `r afilterlowfrequency`
    - high frequency is `r afilterhighfrequency`
1. model sentence length effects (& motion---TODO) by linear regression

## Training & testing

Once these steps are complete we choose a training
and testing split and perform statistical modeling.

# Multivariate statistical modeling

## Formulation

Convert the BOLD to a spatiotemporal representation.  This model is of the form:

$$ Z_k = w + w_{00} x_{00} + w_{01} x_{01} + \cdots + 
 w_{0p} x_{0p} + w_{10} x_{10} + \cdots + w_{tp} x_{tp} + \epsilon$$

where $w$ represents a weighting term, $Z_k$ represents a multivariate outcome (an
_eigensentence_) at time k, $x_{lm}$ represents a BOLD measurement at time $l$
and space $m$ and $t$ represents the maximum temporal index within a
short window near event $Z_k$. 

## Matrix formulation

So, if $t=0$, then the global time
index is $k$; if $t=1$, the global time index is $k+1$, etcetera.
This formulation allows us to simultaneously model and/or select
variables in space-time.  From here, we denote the right side of the 
above equation (for all $k$) as $XW^T$ where $X$ 
has dimensions $n \times p$ and $W$ has dimensions $k \times p$. 
Similarly, $Z$ is a matrix of
_eigensentence_ representations with dimension $n \times q$. 

## Sparse canonical correlation between space-time BOLD and eigenwords

CCA maximizes $PearsonCorrelation( XW^T, ZY^T )$ where $X, W$ are as above and $Z$
and $Y$ are similarly defined.  CCA optimizes the matrices $W, Y$
operating on $X, Z$ to find a low-dimensional representation of the
data pair $( X , Z )$ in which correlation is maximal.  Following
ideas outlined in @Dhillon2014 and @Avants2014, this method can be
extended with sparsity constraints that yield rows of $W, Y$ with a
controllable number of non-zero entries.

## Predictive model

Given CCA solution matrix $W$, one may employ the low-dimensional
representation, $XW^T$, in multi-label classification.  Currently, we
employ SVM or random forests as multi-label learners for the problem:

$$L_i = f( XW^T ),$$

that is, learning a (sentence) label function from the BOLD data.

(actually, this is a WIP so do not take this too seriously --- see below )

# Study Methodology and Preliminary Validation

Here, we set up parameters for the study, including label sets and temporal filtering.
We can use Brodmann or AAL label sets with the current data though others can easily be added. 
The current parameters select brain regions related to heteromodal association and language.

# References
